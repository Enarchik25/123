import subprocess
import json
from typing import List, Dict
import asyncio
from datetime import datetime
import spidev
import RPi.GPIO as GPIO
import time

class NRF24Pentest:
    def __init__(self):
        self.active_scans = {}
        self.captured_packets = {}
        self.active_attacks = {}
        self.spi = None
        self.ce_pin = 22  # GPIO pin for CE
        self.csn_pin = 0  # CS0 pin for SPI0
        
        # Инициализация GPIO
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(self.ce_pin, GPIO.OUT)
        
        # Инициализация SPI
        self.spi = spidev.SpiDev()
        self.spi.open(0, self.csn_pin)
        self.spi.max_speed_hz = 10000000
        
        # Регистры NRF24
        self.CONFIG = 0x00
        self.EN_AA = 0x01
        self.RF_CH = 0x05
        self.RF_SETUP = 0x06
        self.STATUS = 0x07
        
    def write_register(self, reg: int, value: int):
        """Запись в регистр NRF24"""
        self.spi.xfer2([0x20 | reg, value])
        
    def read_register(self, reg: int) -> int:
        """Чтение из регистра NRF24"""
        resp = self.spi.xfer2([reg, 0x00])
        return resp[1]
    
    async def start_scan(self, start_channel: int = 0, end_channel: int = 125) -> Dict:
        """Запуск сканирования частот"""
        try:
            scan_id = datetime.now().strftime("%Y%m%d_%H%M%S")
            
            # Настройка NRF24 для сканирования
            self.write_register(self.CONFIG, 0x0F)  # RX mode, CRC16, Power Up
            self.write_register(self.EN_AA, 0x00)   # Disable auto-ack
            self.write_register(self.RF_SETUP, 0x0F) # Max power, 2Mbps
            
            # Запускаем сканирование в отдельном процессе
            process = asyncio.create_task(self._scan_frequencies(scan_id, start_channel, end_channel))
            
            self.active_scans[scan_id] = {
                "process": process,
                "start_time": datetime.now(),
                "channels": []
            }
            
            return {
                "status": "success",
                "scan_id": scan_id,
                "message": "Frequency scan started"
            }
        except Exception as e:
            return {"status": "error", "message": str(e)}
            
    async def _scan_frequencies(self, scan_id: str, start_channel: int, end_channel: int):
        """Процесс сканирования частот"""
        try:
            for channel in range(start_channel, end_channel + 1):
                if scan_id not in self.active_scans:
                    break
                    
                # Установка канала
                self.write_register(self.RF_CH, channel)
                
                # Проверка наличия сигнала
                signal_strength = 0
                for _ in range(10):
                    if self.read_register(self.STATUS) & 0x40:
                        signal_strength += 1
                    time.sleep(0.001)
                
                if signal_strength > 0:
                    self.active_scans[scan_id]["channels"].append({
                        "channel": channel,
                        "strength": signal_strength
                    })
        except Exception as e:
            print(f"Scan error: {str(e)}")
            
    async def get_scan_results(self, scan_id: str) -> List[Dict]:
        """Получение результатов сканирования"""
        try:
            if scan_id not in self.active_scans:
                return []
            return self.active_scans[scan_id]["channels"]
        except Exception as e:
            return [{"error": str(e)}]
            
    async def start_packet_capture(self, channel: int) -> Dict:
        """Запуск захвата пакетов на выбранном канале"""
        try:
            capture_id = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"/tmp/nrf24capture_{capture_id}.pcap"
            
            # Настройка NRF24 для приема
            self.write_register(self.CONFIG, 0x0F)  # RX mode, CRC16, Power Up
            self.write_register(self.EN_AA, 0x00)   # Disable auto-ack
            self.write_register(self.RF_SETUP, 0x0F) # Max power, 2Mbps
            self.write_register(self.RF_CH, channel) # Set channel
            
            # Запускаем захват в отдельном процессе
            process = asyncio.create_task(self._capture_packets(capture_id, filename))
            
            self.captured_packets[capture_id] = {
                "process": process,
                "filename": filename,
                "channel": channel,
                "start_time": datetime.now(),
                "packets": []
            }
            
            return {
                "status": "success",
                "capture_id": capture_id,
                "message": "Packet capture started"
            }
        except Exception as e:
            return {"status": "error", "message": str(e)}
            
    async def _capture_packets(self, capture_id: str, filename: str):
        """Процесс захвата пакетов"""
        try:
            while capture_id in self.captured_packets:
                if self.read_register(self.STATUS) & 0x40:
                    # Получаем пакет
                    packet = self.spi.xfer2([0x61] + [0xFF] * 32)  # R_RX_PAYLOAD command
                    
                    # Сохраняем пакет
                    self.captured_packets[capture_id]["packets"].append({
                        "timestamp": datetime.now().isoformat(),
                        "data": packet[1:]  # Пропускаем первый байт (команда)
                    })
                    
                    # Очищаем флаг прерывания
                    self.write_register(self.STATUS, 0x40)
                    
                await asyncio.sleep(0.001)
        except Exception as e:
            print(f"Capture error: {str(e)}")
            
    async def stop_capture(self, capture_id: str) -> Dict:
        """Остановка захвата пакетов"""
        try:
            if capture_id in self.captured_packets:
                capture = self.captured_packets[capture_id]
                capture["process"].cancel()
                
                # Сохраняем захваченные пакеты в файл
                with open(capture["filename"], "w") as f:
                    json.dump(capture["packets"], f)
                    
                del self.captured_packets[capture_id]
                return {"status": "success", "message": "Capture stopped"}
            return {"status": "error", "message": "Capture not found"}
        except Exception as e:
            return {"status": "error", "message": str(e)}
            
    async def replay_packet(self, packet_data: List[int], channel: int) -> Dict:
        """Воспроизведение захваченного пакета"""
        try:
            # Настройка NRF24 для передачи
            self.write_register(self.CONFIG, 0x0E)  # TX mode, CRC16, Power Up
            self.write_register(self.EN_AA, 0x00)   # Disable auto-ack
            self.write_register(self.RF_SETUP, 0x0F) # Max power, 2Mbps
            self.write_register(self.RF_CH, channel) # Set channel
            
            # Отправка пакета
            self.spi.xfer2([0xA0] + packet_data)  # W_TX_PAYLOAD command
            
            # Ждем отправки
            time.sleep(0.001)
            
            return {
                "status": "success",
                "message": "Packet replayed"
            }
        except Exception as e:
            return {"status": "error", "message": str(e)}
            
    def __del__(self):
        """Очистка при уничтожении объекта"""
        if self.spi:
            self.spi.close()
        GPIO.cleanup() 